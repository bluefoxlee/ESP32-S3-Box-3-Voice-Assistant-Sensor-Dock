substitutions:
  name: s3box3-voice-asst-sd
  friendly_name: S3 Box 3 Voice Assistant SD
  micro_wake_word_model: okay_nabu  # options: okay_nabu, hey_jarvis, alexa
  noise_suppression_level: '3'

  # ----- TODO: Fill these in with your device's values
#  ota_password: "0922742660"
#  encryption_key: "0922742660"
  # ----- TODO: Fill these in with the path to your local sound files.  Use HTTP as HTTPS can induce 2+ seconds of lag when playing.
  wakeword_sound: 'https://192.168.1.200:8123/local/sounds/wakeword.mp3'
  success_sound: 'https://192.168.1.200:8123/local/sounds/success.mp3'
  error_sound: 'https://192.168.1.200:8123/local/sounds/error.mp3'

  # ----- don't mess with anything below this line -----
  VERSION: '1.3.2'
  ALLOWED_CHARACTERS: " !#%\"()+-./0123456789:;<>?@ABCDEFGHIJKLMNOPQRSTUVWYZ[]_abcdefghijklmnopqrstuvwxyz{|}°²³µ¿ÁÂÄÅÉÖÚßàáâãäåæçèéêëìíîðñòóôõöøùúûüýþāăąćčďĐđēėęěğĮįıļľŁłńňőřśšťũūůűųźŻżŽžơưșțΆΈΌΐΑΒΓΔΕΖΗΘΚΜΝΠΡΣΤΥΦάέήίαβγδεζηθικλμνξοπρςστυφχψωϊόύώАБВГДЕЖЗИКЛМНОПРСТУХЦЧШЪЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюяёђєіїјљњћạảấầẩậắặẹẽếềểệỉịọỏốồổỗộớờởợụủứừửữựỳ：。一乙丁七乃九了二人儿入八几刀刁力十卜厂又万丈三上下个丫丸久么义乞也于亏亡亿凡刃勺千叉口土士夕大女子寸小尸山川工己已巳巾干广弓才门飞马不与丑中丰丹之予云互五井亢什仁仅仆仇今介仍从仏允元內公六内円冈冗凤凶分切刈劝办勻勾勿匀化匹区升午卞厄历及友双反収壬天太夫孔少尤尹尺屯巴币幻开弔引心戈戶户戸手扎支文斗斤方无日曰月木欠止歹毋比毛氏气水火爪父片牙牛犬王见贝车韦风且世丘丙业东主丼乍乎乏仔仕他仗付仙仟代令以仪兄充冉冊册写冬凸凹出刊功加务包匆北匝卉半占卡卯厉去发古句另叩只叫召叭叮可台叱史右叶号司叹叼囚四圣圧处外央夯失头奴奶孕宁它对尔尻尼左巧巨市布平幼庁広弁弗弘归必戊扑扒打扔斥旦旧未末本札术正母民氷永汀汁汉犯玄玉瓜瓦甘生用甩田由甲申电白皮皿目矛矢石示禾穴立轧邓长鸟龙丟両丢乒乓乔争亘亚交亥亦仮仰仲件价任份仿企伊伍伎伏伐休众优伙会伝兆先光全共关兴再农冰冲决冴刑划列刘劣动匈匠匡华协印危压吁吃各合吉吊同名后吏吐向吓吕回因团団在圭地壮多夷夸奸她好如妃妄妆字存宅宇守安寺尖尘尽屹岁州巩帆师年并庄庆异式弛当忙戌戍戎戏成托扛扡扣扦执收旨早旬旭曲曳有朱朴朵机朽杀杂次欢此死毎氖汎汐汕汗汙汚汛汝江池污灯灰牝牟百礼竹米糸纤缶网羊羽老考而耳肉肋肌臣自至臼舌舛舟色艾虫血行衣西设边辺辻込页齐两串乱亜亨伯估伴伶伸伺似伽佃但位低住佐佑体何余佛作你佣克兌免児兑兵况冶冷删判別刨利刪别助努劫励劳労匣医卤即却卵君吝吞吟吠否吧吨吩含听吭吮启吱吳吴吵吸吹吻吼吾呀呂呆呈呉告呐呑囤囪园困囱囲図圾址坂均坊坍坎坏坐坑块坛坟壯声壱売夾妊妒妓妖妙妝妥妨孜孝宋完宍宏対寿尾尿局屁岐岔岗巡巫希庇床序庐廷弃弄弟形彤役彻忌忍志忘応忧快忱忻怀我戒戻扭扮扯扰扱扳扶批扼找技抄抉把抑抒抓投抖抗折抚抛抜択护报改攻旱时更杆杉李杏材村杖杜杞束杠条来步每求汞汪汰汲汹決汽汾沁沂沃沈沉沏沒沖沙沛沟没沢沪灵灶灸灼災灾灿牡牢状犹狂狄玖甫男甸町皂盯矣禿秀私究系纬纺罕肖肘肚肛肝育良艺芋芍芒見角言谷豆貝赤走足身車辛辰达迁迂迄迅过迈邑邢那邦邪酉里间阪阮防阳阴麦龟並丽乖乳事些亞享京佩佬佯佰佳併使侄來侈例侍侖侗供依侠価侣侨兒兔兩其具典净凭函初刮到制刷券刹刺刻刽剁効劾势卑卒卓協单卧卷卸叁参叔取受变呢周呪味呵呸呻呼命咀咆咋和咎咏咐咒咕咖固国坡坤坦坪坯坷垃壳备夜奄奇奈奉奋奔妮妳妹妻姆姉始姐姑姓委孟季孤学宕宗官宙定宛宜宝实実尚尭居屆屈屉届岡岩岬岭岳岸帕帖帘帚帛幸底店庙庚府延弥弦弧录彼往征径忠念忽忿怔怕怖怜性怪怯总或房所承抨披抬抱抵抹押抽抿拂拄担拆拇拈拉拋拌拍拎拐拒拓拔拖拘拙招拝拟拠拡拥放斉斧於旺昂昆昇昌明昏易昔朋服杭杯杰東杵松板极构枉析枕林枚果枝枠枢枣欣欧武歧歩殴氓氛沫沮河沸油治沼沽沾沿況泄泅泊泌法泛泞泡波泣泥注泪泳炉炊炎炒炔炕炙爬爭爸版牧物狀狐狗狙狛玩玫环画疙疚的盂盲直知矽矾社祁秃秆秉空糾织经罗羌者股肢肤肥肩肪肮肯肺臥舍舎芙芜芝芥芦芬芭芯花芳芸芹芽苅虎虱补表询軋轮迎运近返还这远迟邮邯邱邵邸邹邻采金長門阜阻阿陀附际隶雨青非鱼齿乗亭亮亲侮侯侵侶便係促俄俊俏俐俗俘保俞俠信俣俩兹冒冠剃則削前勁勃勅勇勉南単卻厘厚叙叛咨咬咯咱咲咳咸咽哀品哄哆哇哈哉响哎垂型垒垛垢垣垦垫垮城変复奎奏契姚姜姥姨姫姻姿威娃娄孩孪客宣室宦宪宫封屋屍屎屏峙峡峦巷巻帝帥幽度建弯彥彦待很徊律後怎怒思怠急怨恃恍恒恢恤恨恫恬恼战扁拜括拭拯拱拴拷拼拽拾持挂指按挎挑挖挟挡挣政故施既星映春昧昨昭是昼枯架枷柄柏某柑柒染柔柚柜柞柠查柬柯柱柳柵査柿栃栄栅树歪殃殆段毒毖毗毡氟泉泵洁洋洒洗洛洞津洪洱洲洶洸活洼洽派流浄浅济炬炭炮炯炳炸点為炼炽牲狠狡狩独狭玲玻珂珊珍珐瓮甚甭界畏畑疤疥疫癸発皆皇盅盆盈相盼盾省眉看県砂砌砍砒研砕祇祈祉禹秋种科秒穿突窃竿类籽紀約紅紉统缸美耍耐耶胃胆背胎胖胚胜胞胡脉致苑苔苗苛苞苟若苦苫苯英苹茁茂范茄茅茎荣虐虹虽虾衍衫要视訂訃計貞負赳赴趴軌軍迢迦迪迫迭述郁郊郎酋重钟钢陋陌降限陕面革韋韭音頁風飛食首香乘修俯俱俳俵俸俺倆倉個倍們倒倔倘候倚借倡倣値倦倪倫倭倶倹值党兼冤冥凄准凉凋凌凍剔剖剛剝剣剤剥剧匪卿原員哥哦哨哩哪哭哮哲哺哼唁唄唆唇唉唐圃埂埃埋埔夏套姬娘娛娜娟娠娥娩娯娱孫宮宰害宴宵家容宾射将屑展峨峪峭峯峰島峻峽差師席帮帯帰座庫庭弱徐徑徒従恋恐恕恣恥恩恭息恳恵悄悅悌悍悔悟悦悩扇拳拿挙挛挨挪挫振挺挽挾挿捂捅捆捉捌捍捎捏捐捕捜效敌斋料旁旅時晃晉晋晌晒晓書朔朗柴栓栖栗校株样核根格栽桂桃桅框案桌桐桑桓桔桝桥梳殉殊残殷氣氦氧氨泰浙浚浜浦浩浪浮浴海浸涂涅消涉涌涕涙涛涤烈烏烘烙烛烟烤爹特牺狸狹狼狽珠班琉畔留畜畝畠疲疹疼疽疾病症痈皋益盎真眠眨眩矩砧砰砲破砷砸祐祖祝神祟秘租秤秦秧秩称窄站竜笆笋笏笑笔粉粋紊紋納紐純紗紘紙級紛素紡索缺罢羔翁翅耕耗耘耙耸耻耽耿胯胰胳胴胶胸胺能脂脅脆脇脈脊臭舀舩航般艳苏茗茜茧茨茫茬茲茵茶茸茹草荊荏荐荒荔荘虑蚊蚌蚕蚜蚤衰衷袁袄訊討訓訖託記豈豹豺財貢赶起躬軒辱迷迸迹追退送适逃逆选郝郡酌配酒釘釜針铁铃閃陛陝陡院陣除险隻隼难飢馬骏骨高鬥鬼乾亀假偉偏偕做停健偲側偵偶偷偽兜冕冨减凑凰剪剮副勒動勘務匙匿區厢參唬售唯唱啃啄商啊問啓啞啟啡啤啥啦啪圈國域埠埴執培基埼堀堂堅堆堵壷够夠奢娶娼婁婆婉婚婦婪孰宿寂寄寅密寇將專尉屜屠屡崇崎崔崖崗崩巢巣帳帶常庵庶康庸張強弹彗彩彪彫彬得徘從御恿悉悠患您悪悸悼情惇惊惋惕惚惜惟惦惧惨惮戚捧捨据捷捻掀掂掃掄掇授掉掏掐排掖掘掙掛掠採探接控推掩措掲掺敏救敖敗敘教敝斎斜斬断旋族晚晝晤晦晨曹曼望桶梁梅梆梓梗條梢梦梧梨梭梯械梶棄欲殺殻毫毬氫涎涪涯液涵涸涼淀淄淆淋淌淑淒淖淘淚淡淤淨淩淪淫淬淮深淳淵混淹淺添清渇済渉渊渋渕渗渚烯烴烷烹烽焉焊爽牽犁猎猖猙猛猜率現球琅理瓶瓷甜產産畢略畦異疏疵痊痒痔痕皐盒盔盖盗盘盛眞眯眶眷眺眼眾着睁砦硅硒硫祥票祭离秸移窑窒窓竟章笘笛笠符笨第笹粒粕粗粘粛紮累細紳紹紺終組絆経統缽羚羞翌習聊脖脚脩脫脯脱舵舶舷船荷荻莆莉莊莎莖莢莫获莹莽處虚蛀蛆蛇蛊蛋衅術袋袍袒袖袜被規覓訛訝訟訣訪設許豚貧貨販貪貫責赦趾跃躯軟転透逐递逓途逗這通逛逝逞速造逢連部郭郴郷都酔酗酚酞野釣釧釩釺铜银閉陪陰陳陵陶陷陸雀雪雫頂頃魚鳥鹵鹿麥麻黄黒傀傅傍傑傘備傣凱剩剰割創勝勞博厦厨唾啼喀喂善喇喉喊喋喘喚喜喝喧喪喫喬單喲喳営喻圍圏堡堤堪堯堰報場堺堿塀壹壺奠奥婿媒媚媛富寐寒寓尊尋就属嵌嵐巽帽幀幂幅幾廁廂廃廄廊强弾彭復循悲悶惑惠惡惣惩惰惱惶惺愉慨扉捶掌掣揀揃揉揍描提插揖揚換握揣揩揪揭揮援揺敞敢散敦斌斐斑斯晩普景晰晴晶智晾暁暑曾替最朝期棉棋棍棒棕棗棘棚棟棠棧森棱棲棵棺椅植椎椒椙検欺欽款歯殖殘殼毯氮氯氰渙減渝渠渡渣渤渥渦温測渭港渴游渺渾湃湊湍湖湘湛湧湯湾満溉滋焙焚無焦焰然煮爲牌犀猩猪猫猴猶琢琳琴琵琶琺琼甥甦甯番畫疎痘痙痛痞痢登發皓皖盜短硝硬确硯祷禄稀稅稈程稍税窖窗窘竣童筆等筋筍筏筐筑筒答策粟粤粥粧紫結絕絞絡絢給絨絮絲絵絶缆羡翔联肅脹脾腆腊腋腎腑腔腕臯舒舜荆药菅菇菊菌菏菓菜菠菩華菱菲萄萊萌萍萎著虛蛔蛙蛛蛤蛭蛮衆街袱袴裁裂装視覚訴診証詐詔評詛詞詠象貯貰貳貴貶買貸費貼貿賀趁超越趋跋跌跑距軸軽辜逮週進逸逻郵鄂鄉酢酣酥量鈉鈍鈎鈔鈕鈞鈣開閏閑間陽隅隆隈隊隋階雁雄雅集雇雰雲韌項順須飯飲馭馮黃黍黑亂催傭傲傳債傷傻傾僅働剿募勢勤勧厩叠嗅嗆嗎嗓嗚嗜嗡嗣園圓塊塌塑塔塗塘塙塚塞塢塩填奧奨媳媽嫁嫂嫉嫌寛寝嵯幌幹廈廉彙微想惹愁愈意愚愛感愧慈慌慎戦損搏搐搓搔搖搗搜搞搪搬搭搶携搽搾摆摇敬数斟新暇暈暉暖暗會椰椽椿楊楓楔楕楚楞楠楢業極楷楼楽概榆榊榔歇歲歳殿毀毁源準溜溝溢溥溪溫溯溶溺滁滄滅滇滑滓滔滚滝滦滨滩煉煌煎煙煞煤煥照煩爺献猷猾猿獅瑚瑛瑞瑟當畸痰痴痹瘁盞盟睛睜督睦睫睬睹矮硼碁碉碌碍碎碑碓碗碘碰祿禁禽稔稗稚稜稠窟竪筷筹節粮粱粳粵絹綁綏經継罩罪置署群羨義聖聘肄肆腥腦腫腮腰腳腸腹腺舅艇萩萬萱落葉葛葡董葦葫葬葱葵葷蒂虜虞號蛹蛻蛾蜀蜂蜕衙裏裔裕裙補裝裡解触詢詣試詩詫詭詰話該詳詹誅誇誠豊豢貉賂賃賄資賈賊跟跡跨跪路跳跺躲較載输辞辟農逼逾遁遂遅遇遊運遍過遏道達違鄒鄖酪酬酮釉鈴鈾鉀鉄鉑鉗鉚鉛鉢銃锭閘随隔隕隘雍雏零雷雹電靖靳靴靶韮韵頌預頑頒頓飼飽飾馱馳馴鳩鼎鼓鼠像僑僕僚僞僥僧僳兢凳劃劄厭嗽嘆嘉嘎嘔嘗嘘嘛圖團塵塹塾境墅墊墒墓増墙壽夢夥奪嫡嫩孵寞察寡寢寥實寧寨對屢嶄嶋嶌幕幣廓廖弊彰徳徴徹愿態慘慚慢慣慷截摔摘摟摧摳摸摻撂撇撤敲斡旗暢暦榎榛榜榨榮榴榷構槌槍槐槙歉歌歴滌滬滯滲滴滾滿漁漂漆漏漓演漕漚漠漢漣漫漬漱漲漳漸漾澈煽熄熊熏熒熔熙爾獄瑠瑣瑤瑪瑰瑶甄疑瘋瘍瘓瘧盡監睡瞄瞅碟碧碩碱碳碴磁禍禎福稭種稱稲稳窩窪竭端箋箍箏箔箕算管箸粹精綜綠綢維綱網綴綸綺綻綽綾綿緊緋総緑緒罰翟翠聚聞聡肇腐腿膀膊膏臺與舔舞萤蒔蒙蒜蒲蒸蒼蓄蓉蓋蓑蓖蜒蜘蜜蜡蜷蝇蝕裳裴裸裹製裾褂誌認誓誘語誡誣誤誦誨說説豪貌賒賓赫趕趙踊輔輕辣遙遜遞遠遣鄙酵酶酷酸鉸鉻鉾銀銅銑銕銘銚銜銥銭閡関閣閥閨閩隙際障隠雌雑需静韶頗領頚餃餅餌駁駄駅駆髪魁魂鳳鳴麼麽鼻齊僵價僻儀億儈儉凛凜劇劈劉劊劍勲厲嘩嘯嘱嘲嘴嘶嘻嘿噂噎噓噴墜增墟墨墩墮墳嬉嬌審寫寬寮層履幟幡幢廚廟廠廢廣彈影德慕慧慫慮慰慶憂憋憎憐憚憤憧憫戮戯摩摯摹撃撅撈撐撑撒撓撕撚撞撣撥撩撫撬播撮撰撲敵敷數暫暮暴様槳槻槽樁樂樊樋樓標樞樟模樣権横樫歎歐歓毅毆漿潑潔潘潛潜潟潤潦潭潮潰澄澆澇澎澗熟熬熱獎瑩璃畿瘟瘡瘤瘦瘩皚皺盤瞎瞑確碼碾磅磊磋磐磕稻稼稽稿穀穂窮窯箭箱範篆篇糊緘線緝緞締緣編緩緬緯練緻縁縄罵罷翫聪膘膚膛膜膝膠蓬蓮蓼蔑蔓蔔蔗蔚蔡蔣蔥蔦蔫蔬蔭蔵蔽蝎蝗蝦蝴蝶蝸衛衝複褐褒誕誰課誹誼調諄談請諌諏諒論諸豌豎豬賛賜賞賠賢賣賤賦質賬賭趟趣踏踐踞踢踩踪躺輛輝輥輩輪適遭遮遷鄧鄭鄰鄲醇醉醋銳銷銻鋁鋅鋇鋒鋤鋪鋭鋳镇閱閲隣霄震霉霊靠鞋鞍鞏養餒餓餘駐駒駕駛駝鬧魄魅魯鴈鴉黎齒儒冀冪凝劑勳器噪噬噶噸噺墾壁壇壊奮嬢學導彜憊憑憨憩憲憶憾懈懊懐戰撻撼撾撿擁擂擄擅擇擋操擒擔據整曆曇曉樸樹樺樽橇橋橘橙機橡橢橫橱潞澡澤澱澳激濁濃熾燃燈燎燒燕燙獨瓢瘴瘸盧瞞瞥磚磨禦穆積穎穏窺築篙篡篤篩篭簑糕糖縛縞縣縦縧翰翱耪膨膩膳臻興舘艘艙蕃蕉蕊蕨蕩蕪蕭融螞螟螢衡褥褪褲覧親諜諦諧諭諮諱諷諺諾謀謂豫貓賴踴蹄輯輸輻辦辨遲遵選遺遼醍醒鋸鋼錄錐錠錢錦錫錬錯録錳鍁鍺閹閻隧隨險隷雕霍霓霖靛靜鞘頤頭頰頸頹頻頼餐餞餡館駭駱骸鮎鮑鴕鴛鴦鴨黔默黙龍龜償儡優儲勵厳嚇嚎嚏壓壕嬰孺嶺嶼嶽幫彌徽懂懇應懦戲戴擊擎擠擡擦擬擯擰擱斂斃曙橿檀檄檔檜檢櫛氈澀濕濘濟濡濤濫濯濰濱營燥燦燭燴爵牆獰獲環療癌瞧瞩瞪瞬瞳矯磯磷磺礁穗窿篠篱篷簇簍糙糜糞糟糠縫縮縱縷總績繁繃翼聯聰聲聳聴膽膿臀臂臃臆臉臨舉艱蕾薄薊薔薛薦薪薫薬薯虧螺蟄襄謄謅謊謎謗謙講謝謠豁賺購賽趨蹈蹋輾輿轄轅避邀邁還醚醛醜醞錘錨鍋鍍鍘鍛鍬鍵鍼鍾鎂闇闊闌隱隸雖霜霞鞠韓顆駿騁鮫鮭鮮鴻鴿黛點齋叢壘嬸彝戳擲擴擺擻擾攆斷旛曜檬檸檻櫃歸濺濾瀉瀋瀑燼獵甕癒癖瞻礎礒禮穢竄竅簡簧糧織繕繞繡翹翺翻聶職臍舊薩藁藉藍藏藐蟬蟲覆観謬謳謹謾豐贅蹤蹦軀轉轍醫醬鎊鎌鎖鎢鎬鎮鎳闖闘雙雛雜雞離鞭題額顏顔顕餾騎鬃魏鯉鵑鵜鵝鵠嚨壞壟寵廬懲懶懷攀攏曝曠櫥瀕瀝瀬爆爍犢獸獺瓊瓣疆疇癟癡礙禱穩穫簽簾簿繩繪繭繰繳繹羅羹臘艶藕藝藤藥藩蟹蟻蠅蠍襖襟覇證譏識譚譜贈贊贋蹬蹭蹲蹴躇轎辭邊鏈鏟鏡關隴難霧靡韻願顛類饅騙鯛鯨鵬鵲麓麗龐勸嚴嚷嚼壤孽寶巌懸攔攘攙瀾爐獻癢礦礫礬競籃籌籍糯繼纂耀艦藹藻蘆蘇蘊蘋蘑蠕覺觸警譬譯議贍贏躁辮釋鏽鐐鐘闡飄饋饑饒馨騰騷髄鰓鹹黨齡齢囂囃屬巋巍懼懾攜攝櫻欄殲灌爛犧竈續纏蘭蠟蠢襪覽譴護譽贓躊躍轟辯鐮鐳鐵露霸霹響顧饗騾驅魔鶴齧囊孿巒彎攢攤權歡灑灘瓤疊癬籠聽聾襯襲讀讃贖鑄鑑鑒顫驕髒鷗龔戀攣攪攫曬癰竊纓纖蘸蘿蠱變邏顯驗驚髓體鱒鱗鷲黴囑壩攬癱矗罐蠶讒讓讕贛釀靈驟鷹鷺鹽齲廳灣籬籮蠻觀躥釁鑰鑲顱饞鼈灤矚鑷驢纜鑼鑽顴豔鑿籲专丛丝严丧临为举乌乐习乡书买产亩仑仓们伞伟传伤伦伪侥侦侧侩俭债倾偿储兰养兽军冯冻処凧凯击凿则刚创剂剐剑劲勋匂卖卢卫厅厌厕县吗呕员呛呜咙哑哗哟唤啮啸喷噛嚣围图圆场坚坝坞坠垄堑堕塁壌壶夹夺奖妇妈娇婴婶孙宠审宽寻导専尝尧层屿岂岛岿峠崭帅帐帜带帧库应庞废张忆态怂恶悬悯惫惭惯愤慑懒払扩扫扬抠抡抢拢拣拦拧拨择挚挝挞挠挤挥捞损捡换捣掳掷掸揽搀搁搂搅摂摄摈摊撵擞攒敛斩旷显晕暂曽权杨枪枫标栈栋栏桜桟档桧桨桩检椭槛樱歼毕毙気氢汇汤沤沥沦沧泻泼泽浆浇浊测浑浓涝涟涡涣润涧涨涩渍渐渓渔湿溃溅滞满滤滥潍澜濒灭烁烂烃烦烧烩烫烬热焕焼煕爱爷牵犊犠狈狞狮狰狱猟獣獭玛现琐畅畳畴疗疟疡疮疯痉痪瘪瘫癣皑皱盏盐监瞒矫矿码砖砚砾础硕祸禅积秽穣穷窍窜窝窥竖竞笺笼筛签简箩篓篮簗粪紧続繊纠红约级纪纫纯纱纲纳纵纶纷纸纹纽线练组绅细终绊绍绎绑绒结绕绘给绚络绝绞绢绣绥绦继绩绪续绰绳维绵绷绸综绽绿缀缄缅缉缎缓缔缕编缘缚缝缠缨缩缮缴罚翘聂聋职肃肠肾肿胀胁脏脐脑脓脳脸腻腾臓舆舗舰舱艰节苇苍荚荡荤荧荫莱莲萝营萧萨蒋蓝蓟蔷蔼蕴薮虏蚀蚁蚂蛍蛰蜗蝉衔衬袭裤观规觅览觉訳誉誊読謡譲计订讣认讥讨让讫训议讯记讲讳讶许讹论讼讽访诀证评诅识诈诉诊诌词译试诗诚诛话诞诡诣该详诧诫诬语误诱诲说诵请诸诺读诽课谁调谅谆谈谊谋谍谎谐谓谗谚谜谢谣谤谦谨谩谬谭谰谱谴贞负贡财责贤败账货质贩贪贫贬购贮贯贰贱贴贵贷贸费贺贼贾贿赁赂赃资赊赋赌赎赏赐赔赖赘赚赛赞赠赡赢赣赵践踌蹿轨轩转软轰轴轻载轿较辅辆辈辉辊辐辑辕辖辗辙辩辫辽进违连逊遗遥郑郧郸酝酱酿醤醸釈释鉱鉴针钉钎钒钓钙钝钞钠钡钥钦钧钨钩钮钱钳钵钻钾铀铂铅铆铝铡铣铬铭铰铱铲铸铺链销锁锄锅锈锋锌锐锑锗错锚锡锣锤锥锦锨键锯锰锹锻镀镁镊镍镐镑镜镣镭镰镶闪闭问闯闰闲闷闸闹闺闻闽阀阁阂阅阉阎阐阑阔队阵阶陆陇陈陥陨険隐雾韧韩頬顶顷项顺须顽顾顿颁颂预颅领颇颈颊颐频颓颖颗题颜额颠颤颧飘饥饭饮饯饰饱饲饵饶饺饼饿馁馅馆馈馋馏馒騒験驭驮驯驰驱驳驴驶驹驻驼驾骂骄骆骇骋验骑骗骚骡骤鲁鲍鲜鲤鲸鳃鳖鳞鴎鶏鸡鸣鸥鸦鸭鸯鸳鸵鸽鸿鹃鹅鹊鹏鹤鹰麹麺龄龋龚捲閒聆嗶喔鬆傢嗨儘嗯　，、＇∶；‘’“”〝〞ˆˇ﹕︰﹔﹖﹑•¨…¸！´？～—ˉ｜‖＂〃｀﹫¡﹏﹋﹌︴々﹟﹩$﹠&﹪*﹡﹢﹦﹤‐￣¯―﹨˜﹍﹎=＿🌹🎂🎈🎉👀👆👇👈👉👊👋👌👍👎👏💀💋💐💕💖💗💙💜💞💪💯🔥🖕😀😁😂😃😄😅😆😇😈😉😊😋😍😎😏😔😕😘😜😠😡😢😩😬😭😯😱😲😳😴😵😶😷😸😹😺😻😼😽😾😿🙀🙂🙄🙈🙌🙏🤔🤗🤘🤞🤟🤣🤤🤦🤪🤷🥰🥳🥺✨🌟🌬"
  
  VA_IN_HOME_ASSISTANT: "伺服器"
  VA_ON_DEVICE: "裝置"

  VA_SPEAKER_SPEECH: "語音"
  VA_SPEAKER_BEEP: "提示音"
  VA_SPEAKER_MUTE: "靜音"

  APP_STATE_LOADING: '0'
  APP_STATE_STATUS: '1'
  APP_STATE_IR_LEARNING: '2'
  APP_STATE_IR_BLAST: '3'
  APP_STATE_VA: '4'
  APP_STATE_SETTINGS: '5'
  APP_STATE_SCREEN_SAVER: '6'
  APP_STATE_TOUCHSCREEN_ERROR: '7'
  NUM_PAGES: '6'

  VA_STATE_NOT_READY: '1'
  VA_STATE_IDLE: '2'
  VA_STATE_LISTENING: '3'
  VA_STATE_THINKING: '4'
  VA_STATE_REPLYING: '5'
  VA_STATE_ERROR: '6'
  VA_STATE_MUTED: '7'

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2025.2.0
  name_add_mac_suffix: true
  on_boot:
    priority: 600
    then:
      - light.turn_on: 
          id: led
          brightness: 100%
      - display.page.show: loading_page
      - component.update: s3_box_lcd
  includes:
    - custom_text_helpers.h  # 包含自定義函數
  project:
    name: "AlmostInteractive.VoiceAssistantSensorDock"
    version: ${VERSION}

esp32:
  board: esp32s3box
  flash_size: 16MB
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"

psram:
  mode: octal
  speed: 80MHz

ota:
  - platform: esphome
    password: "0922742660"

logger:
  hardware_uart: USB_SERIAL_JTAG
  level: DEBUG
  logs:
    micro_wake_word: WARN
    sensor: WARN
    binary_sensor: WARN
    esp-idf: WARN
    esp_adf_pipeline: WARN
    esp_audio_processors: WARN
    esp_audio_sources: WARN

api:
  id: my_api
  encryption:
    key: "b5l9EfZwm+guxPPi7RKwpkKxo7CZ/ZjtCn5QFzTG7y8="
  on_client_connected:
    - script.execute: check_touchscreen_failure
    - component.update: s3_box_lcd
  on_client_disconnected:
    - component.update: s3_box_lcd

captive_portal:

wifi:
  ssid: "FI"
  password: "FI0922742660"
  ap:
    ssid: ${name}
    password: "0922742660"
  on_connect:
    - script.execute: check_touchscreen_failure
    - script.wait: check_touchscreen_failure
    - if:
        condition:
          - lambda: return id(touchscreen_error_counter) < 0;
        then:
        - script.execute: box_initialize
        - script.wait: box_initialize
        - script.execute:
            id: change_app_state
            nextState: ${APP_STATE_STATUS}
  on_disconnect:
    - component.update: s3_box_lcd

time:
  - platform: homeassistant
    id: ha_time

output:
  - platform: ledc
    pin: GPIO47
    id: backlight_output

light:
  - platform: monochromatic
    id: led
    name: 'LCD 螢幕'
    icon: 'mdi:television'
    entity_category: config
    output: backlight_output
    restore_mode: RESTORE_DEFAULT_ON
    default_transition_length: 500ms

spi:
  - id: spi_bus
    clk_pin: 7
    mosi_pin: 6

i2c:
  - id: bus_a
    sda: GPIO08
    scl: GPIO18
    scan: false
    sda_pullup_enabled: true
    scl_pullup_enabled: true
    frequency: 100kHz

  - id: bus_b
    sda: GPIO41
    scl: GPIO40
    scan: false
    sda_pullup_enabled: true
    scl_pullup_enabled: true
    frequency: 50kHz

i2s_audio:
  - id: i2s_audio_bus
    i2s_lrclk_pin: GPIO45
    i2s_bclk_pin: GPIO17
    i2s_mclk_pin: GPIO2

audio_adc:
  - id: es7210_adc
    platform: es7210
    i2c_id: bus_a
    bits_per_sample: 16bit
    sample_rate: 16000

audio_dac:
  - id: es8311_dac
    platform: es8311
    i2c_id: bus_a
    bits_per_sample: 16bit
    sample_rate: 48000

microphone:
  - platform: i2s_audio
    id: box_mic
    sample_rate: 16000
    i2s_din_pin: GPIO16
    bits_per_sample: 16bit
    adc_type: external

speaker:
  - platform: i2s_audio
    id: box_speaker
    i2s_dout_pin: GPIO15
    dac_type: external
    sample_rate: 48000
    bits_per_sample: 16bit
    channel: left
    audio_dac: es8311_dac
    buffer_duration: 100ms

media_player:
  - id: speaker_media_player
    platform: speaker
    name: "S3 Box 3 媒體播放器"
    announcement_pipeline:
      speaker: box_speaker
      format: FLAC
      sample_rate: 48000
      num_channels: 1  # S3 Box only has one output channel
    on_state:
      - lambda: ESP_LOGD("media_player", "on_state");
    on_play:
      - lambda: ESP_LOGD("media_player", "on_play");
    on_pause:
      - lambda: ESP_LOGD("media_player", "on_pause");
    on_idle:
      - lambda: ESP_LOGD("media_player", "on_idle");
    on_announcement:
      - lambda: ESP_LOGD("media_player", "on_announcement");

micro_wake_word:
  models:
    - ${micro_wake_word_model}
  on_wake_word_detected:
    - if:
        condition:
          lambda: return id(mem_va_speaker_mode).state != "${VA_SPEAKER_MUTE}";
        then:
          - media_player.play_media: ${wakeword_sound}
          - wait_until:
              condition:
                not:
                  media_player.is_idle
              timeout: 2sec
          - wait_until:
              condition:
                media_player.is_idle
              timeout: 2sec
    - if:
        condition:
          - lambda: return id(app_state) == ${APP_STATE_SCREEN_SAVER};
        then:
          - script.execute: 
              id: change_app_state
              nextState: ${APP_STATE_STATUS}
    - voice_assistant.start:
        wake_word: !lambda return wake_word;

voice_assistant:
  id: va
  microphone: box_mic
  media_player: speaker_media_player
  noise_suppression_level: ${noise_suppression_level}
  auto_gain: 31dBFS
  volume_multiplier: 4.0
  on_client_connected:
    - lambda: ESP_LOGD("voice_assistant_on", "on_client_connected");
    - if:
        condition:
          lambda: return id(mem_wake_word_engine_location).state == "${VA_IN_HOME_ASSISTANT}";
        then:
          - lambda: id(va).set_use_wake_word(true);
          - voice_assistant.start_continuous
        else:
          - micro_wake_word.start
    - script.execute:
        id: change_va_state
        nextState: ${VA_STATE_IDLE}
    - lambda: id(va_state) = ${VA_STATE_IDLE};
  on_client_disconnected:
    - lambda: ESP_LOGD("voice_assistant_on", "on_client_disconnected");
    - if:
        condition:
          lambda: return id(mem_wake_word_engine_location).state == "${VA_IN_HOME_ASSISTANT}";
        then:
          - lambda: id(va).set_use_wake_word(false);
        else:
          - micro_wake_word.stop
    - voice_assistant.stop
    - script.execute:
        id: change_va_state
        nextState: ${VA_STATE_NOT_READY}
  on_wake_word_detected:
    - lambda: ESP_LOGD("voice_assistant_on", "on_wake_word_detected");
    - text_sensor.template.publish:
        id: va_request
        state: ""
    - text_sensor.template.publish:
        id: va_response
        state: ""
  on_listening:
    - lambda: ESP_LOGD("voice_assistant_on", "on_listening");
    - script.execute:
        id: change_va_state
        nextState: ${VA_STATE_LISTENING}
  on_stt_vad_start:
    - lambda: ESP_LOGD("voice_assistant_on", "on_stt_vad_start");
  on_stt_vad_end:
    - lambda: ESP_LOGD("voice_assistant_on", "on_stt_vad_end");
    - script.execute:
        id: change_va_state
        nextState: ${VA_STATE_THINKING}
  on_error:
    - lambda: ESP_LOGD("voice_assistant_on", "on_error");
    - if:
        condition:
          - lambda: return id(va_state) != ${VA_STATE_NOT_READY};
        then:
          - script.execute:
              id: change_va_state
              nextState: ${VA_STATE_ERROR}
          - text_sensor.template.publish:
              id: va_response
              state: !lambda return message;
          - if:
              condition:
                lambda: return id(mem_va_speaker_mode).state == "${VA_SPEAKER_BEEP}";
              then:
                - media_player.play_media: ${error_sound}
                - wait_until:
                    condition:
                      media_player.is_idle
                    timeout: 2sec
          #- delay: 3s
          - script.execute:
              id: change_va_state
              nextState: ${VA_STATE_IDLE}
  on_stt_end:
    - lambda: ESP_LOGD("voice_assistant_on", "on_stt_end");
    - text_sensor.template.publish:
        id: va_request
        state: !lambda return x;
    - component.update: s3_box_lcd
  on_tts_start:
    - lambda: ESP_LOGD("voice_assistant_on", "on_tts_start");
    - text_sensor.template.publish:
        id: va_response
        state: !lambda return x;
    - script.execute:
        id: change_va_state
        nextState: ${VA_STATE_REPLYING}
    - if:
        condition:
          - lambda: return id(mem_va_speaker_mode).state != "${VA_SPEAKER_SPEECH}";
        then:
          - wait_until:
              condition:
                not:
                  media_player.is_idle
              timeout: 5sec
          - media_player.stop:
              announcement: true
          - wait_until:
              condition:
                media_player.is_idle
              timeout: 1sec
          - if:
              condition:
                lambda: return id(mem_va_speaker_mode).state == "${VA_SPEAKER_BEEP}";
              then:
                - media_player.play_media: !lambda if(x.rfind("Sorry", 0) == 0) return "${error_sound}"; return "${success_sound}";
                - wait_until:
                    condition:
                      media_player.is_idle
                    timeout: 2sec
  on_end:
    - lambda: ESP_LOGD("voice_assistant_on", "on_end");
    - if:
        condition:
          - lambda: return id(mem_wake_word_engine_location).state == "${VA_ON_DEVICE}";
        then:
          - wait_until:
              condition:
                not:
                  voice_assistant.is_running
              timeout: !lambda 'return id(mem_va_speaker_mode).state != "${VA_SPEAKER_SPEECH}" ? 500 : 180000;' #ms
          - micro_wake_word.start
    - script.execute:
        id: change_va_state
        nextState: ${VA_STATE_IDLE}

  on_intent_start:
    - lambda: ESP_LOGD("voice_assistant_on", "on_intent_start");
  on_intent_end:
    - lambda: ESP_LOGD("voice_assistant_on", "on_intent_end");
  on_start:
    - lambda: ESP_LOGD("voice_assistant_on", "on_start");
  on_tts_end:
    - lambda: ESP_LOGD("voice_assistant_on", "on_tts_end");
  on_idle:
    - lambda: ESP_LOGD("voice_assistant_on", "on_idle");
  on_timer_started:
    - lambda: ESP_LOGD("voice_assistant_on", "on_timer_started");
  on_timer_finished:
    - lambda: ESP_LOGD("voice_assistant_on", "on_timer_finished");
  on_timer_cancelled:
    - lambda: ESP_LOGD("voice_assistant_on", "on_timer_cancelled");
  on_timer_updated:
    - lambda: ESP_LOGD("voice_assistant_on", "on_timer_updated");

touchscreen:
  platform: gt911
  i2c_id: bus_a
  id: gt911_touchscreen
  interrupt_pin: GPIO3

switch:
  - id: enable_ir
    platform: gpio
    name: "IR 供電"
    icon: 'mdi:led-variant-on'
    entity_category: config
    restore_mode: RESTORE_DEFAULT_ON
    pin:
      number: GPIO44
      inverted: true
    on_turn_on: 
      then:
        - component.update: s3_box_lcd
    on_turn_off: 
      then:
        - component.update: s3_box_lcd

select:
  - id: mem_wake_word_engine_location
    platform: template
    entity_category: config
    name: Wake word engine location
    optimistic: true
    restore_value: true
    options:
      - ${VA_IN_HOME_ASSISTANT}
      - ${VA_ON_DEVICE}
    initial_option: ${VA_IN_HOME_ASSISTANT}
    on_value:
      - if:
          condition:
            lambda: return x == "${VA_IN_HOME_ASSISTANT}";
          then:
            - micro_wake_word.stop
            - delay: 500ms
            - lambda: id(va).set_use_wake_word(true);
            - voice_assistant.start_continuous
            - text_sensor.template.publish:
                id: wakeword_location
                state: !lambda 'return "Home Assistant";'
            - component.update: s3_box_lcd
          else:
            - text_sensor.template.publish:
                id: wakeword_location
                state: !lambda 'return "On Device";'
            - lambda: id(va).set_use_wake_word(false);
            - voice_assistant.stop
            - delay: 500ms
            - micro_wake_word.start
            - component.update: s3_box_lcd
  - id: mem_va_speaker_mode
    platform: template
    entity_category: config
    name: VA Speaker Mode
    optimistic: true
    restore_value: true
    options:
      - ${VA_SPEAKER_SPEECH}
      - ${VA_SPEAKER_BEEP}
      - ${VA_SPEAKER_MUTE}
    on_value:
      - delay: 250ms
      - component.update: s3_box_lcd

sensor:
  - platform: aht10 
    i2c_id: bus_b
    variant: AHT20
    temperature:
      name: "溫度"
      id: s3temp
    humidity:
      name: "濕度"
    update_interval: 60s

  - platform: adc
    pin: GPIO10
    name: "電池電壓"
    id: battery_voltage
    unit_of_measurement: "V"
    accuracy_decimals: 1
    device_class: "voltage"
    entity_category: "diagnostic"
    disabled_by_default: true
    update_interval: 30s
    attenuation: auto
    filters:
      - multiply: 4.11

  - platform: copy
    id: battery_percent
    source_id: battery_voltage
    name: "電池電量"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    device_class: "battery"
    entity_category: "diagnostic"
    filters:
      - lambda: return (x - 2.7) / (4.2 - 2.7) * 100;
      - clamp:
          min_value: 0
          max_value: 100

text_sensor:
  - platform: wifi_info
    ip_address:
      name: "ESP IP 位址"
      address_0:
        name: "ESP IP 位址 0"
      id: ip_addr
  - id: wakeword_location
    platform: template
  - id: va_request
    platform: template
  - id: va_response
    platform: template

number:
  - id: mem_settings_sleep_delay
    platform: template
    name: "睡眠延遲"
    icon: 'mdi:sleep'
    entity_category: config
    unit_of_measurement: 'secs'
    optimistic: true
    restore_value: true
    initial_value: 30
    step: 1
    min_value: 1
    max_value: 999999

font:
  - file: "fonts/SarasaUiTC-ExtraLight.ttf"
    id: font_small
    size: 14
    glyphs: ${ALLOWED_CHARACTERS}
  - file: "fonts/Arial Unicode.ttf"
    id: font_medium
    size: 24
    glyphs: "語音助理狀態量睡眠！錯誤觸控畫面設定失敗裝置即將於%秒後重啟。欲取消按下左上鈕0123456789：ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.,:;!?-"
  - file: "fonts/Arial Unicode.ttf"
    id: font_large
    size: 30
    glyphs: "控制設定語音助理紅外線記憶按鈕狀態學習0123456789 ：ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.,:;!?-"
  - file: "fonts/SarasaUiTC-ExtraLight.ttf"
    id: font_extra_large
    size: 60
    glyphs: ['😴']
  - file: "https://github.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/raw/master/fonts/materialdesignicons-webfont.ttf"
    id: font_icon_tiny
    size: 30
    glyphs: [
      "\U000F009A",#bell
      "\U000F009C",#bell-outline
      "\U000F00AD",#block-helper
      "\U000F01F2",#emoticon-outline
      "\U000F0375",#minus-box
      "\U000F0416",#plus-box
    ]
  - file: "https://github.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/raw/master/fonts/materialdesignicons-webfont.ttf"
    id: font_icon_small
    size: 45
    glyphs: [
      "\U000F0079",#battery 100%
      "\U000F0082",#battery 90%
      "\U000F0081",#battery 80%
      "\U000F0080",#battery 70%
      "\U000F007F",#battery 60%
      "\U000F007E",#battery 50%
      "\U000F007D",#battery 40%
      "\U000F007C",#battery 30%
      "\U000F007B",#battery 20%
      "\U000F007A",#battery 10%
      "\U000F10CD",#battery warning
      "\U000F050F",#temp sensor
      "\U000F16BD",#wifi connected
      "\U000F16BC",#wifi disconnected
      "\U000F07D0",#api connected
      "\U000F12A8",#touch button
      "\U000F0EBA",#stats
      "\U000F087B",#api disconnected
      "\U000F057E",#speaker on
      "\U000F0581",#speaker off
      "\U000F0493",#settings cog
      "\U000F06E8",#light bulb illuminated
      "\U000F0335",#light bulb off
      "\U000F0A19",#toggle off
      "\U000F0521",#toggle on
      "\U000F032E",#led-variant-off
      "\U000F0330",#led-variant-outline
      "\U000F004F",#arrow-left-bold-circle
      "\U000F0056",#arrow-right-bold-circle
      "\U000F0375",#minus-box
      "\U000F0416",#plus-box
      "\U000F009A",#bell
      "\U000F00AD",#block-helper
      "\U000F01F2",#emoticon-outline
      ]
  - file: "https://github.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/raw/master/fonts/materialdesignicons-webfont.ttf"
    id: font_icon_large
    size: 65
    glyphs: [
      "\U000F004F",#arrow-left-bold-circle
      "\U000F0056",#arrow-right-bold-circle
      ]

image:
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/notready.png"
    id: notready_img
    type: RGB
    transparency: alpha_channel
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/error.png"
    id: error_img
    type: RGB
    transparency: alpha_channel
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/idle.png"
    id: idle_img
    type: RGB
    transparency: alpha_channel
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/listening.png"
    id: listening_img
    type: RGB
    transparency: alpha_channel
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/thinking.png"
    id: thinking_img
    type: RGB
    transparency: alpha_channel
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/replying.png"
    id: replying_img
    type: RGB
    transparency: alpha_channel
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/loading.png"
    id: loading_img
    type: RGB
    transparency: alpha_channel

color:
  - id: green
    hex: '75D15F'
  - id: red
    hex: 'FF3131'
  - id: blue
    hex: '47B7E9'
  - id: blue_light
    hex: 'CFE2F3'
  - id: blue_dark
    hex: '085296'
  - id: amber
    hex: 'FBAB35'
  - id: lime
    hex: '20FC30'
  - id: pink
    hex: 'D92BBC'
  - id: yellow
    hex: 'FFC000'
  - id: black
    hex: '000000'
  - id: white
    hex: 'ffffff'
  - id: purple
    hex: '73264D'
  - id: grey_dark
    hex: '202020'

globals:
  # saved to flash
  - id: mem_ir_code_1
    type: int[256]
    restore_value: true
  - id: mem_ir_code_2
    type: int[256]
    restore_value: true
  - id: mem_ir_code_3
    type: int[256]
    restore_value: true
  - id: mem_ir_code_4
    type: int[256]
    restore_value: true
  # saved in ram
  - id: app_state
    type: int
    restore_value: false
    initial_value: ${APP_STATE_LOADING}
  - id: wake_app_state
    type: int
    restore_value: false
  - id: nav_lock
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: ir_memory_button_selected
    type: int
    restore_value: false
    initial_value: '-1'
  - id: ir_memory_button_codes
    type: std::vector<std::string>
    restore_value: false
  - id: ir_learning_state
    type: int
    restore_value: false
    initial_value: '0'    # 0 = pick a button, 1 = button picked, waiting to turn on, 2 = waiting for control signal, 3 = waiting to turn on, 4 = waiting for control signal
  - id: ir_learning_step
    type: int
    restore_value: false
    initial_value: '0'    # 0 = just started, 1 - 2 = recordings to make
  - id: ir_memory_last_received
    type: int
    restore_value: false
    initial_value: '0'
  - id: ir_memory_recording_codes
    type: std::vector<std::string>
    restore_value: false
  - id: ir_memory_recorded_codes
    type: std::vector<std::vector<std::string>>
    restore_value: false
  - id: radar_last_seen
    type: int
    restore_value: false
    initial_value: '-1'
  - id: va_state
    type: int
    restore_value: false
    initial_value: ${VA_STATE_NOT_READY}
  - id: mute_error
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: touchscreen_error_counter
    type: int
    restore_value: false
    initial_value: '-1'
  - id: ignore_touchscreen_error
    type: bool
    restore_value: false
    initial_value: 'false'

script:
  - id: box_initialize
    then:
      - lambda: |-
          id(ir_memory_button_codes).resize(4, "");

          int* codeArray;
          int length;
          std::string hexStr;
          char buffer[5];
          int* data;

          for (int i = 0; i < 4; i++) {
            switch (i) {
              case 0:
                codeArray = id(mem_ir_code_1);
                break;
              case 1:
                codeArray = id(mem_ir_code_2);
                break;
              case 2:
                codeArray = id(mem_ir_code_3);
                break;
              case 3:
                codeArray = id(mem_ir_code_4);
                break;
            }
          
            length = codeArray[0];
            if (length <= 0) {
              continue;
            }

            hexStr.clear();
            data = codeArray + 1;
            for (int i = 0; i < length; i++) {
              snprintf(buffer, 5, "%04X", data[i]);
              hexStr += buffer;
              if (i != length - 1) {
                hexStr += " ";
              }
            }

            id(ir_memory_button_codes)[i] = hexStr;
          }
  - id: change_app_state
    parameters:
      nextState: int
    then:
      - lambda: |-
          id(app_state) = nextState;
          switch (nextState) {
            case ${APP_STATE_LOADING}:
              id(s3_box_lcd).show_page(id(loading_page));
              break;
            case ${APP_STATE_STATUS}:
              id(s3_box_lcd).show_page(id(status_page));
              break;
            case ${APP_STATE_IR_LEARNING}:
              id(s3_box_lcd).show_page(id(ir_learn_page));
              break;
            case ${APP_STATE_IR_BLAST}:
              id(s3_box_lcd).show_page(id(ir_blast_page));
              break;
            case ${APP_STATE_VA}:
              id(s3_box_lcd).show_page(id(voice_assistant_page));
              break;
            case ${APP_STATE_SETTINGS}:
              id(s3_box_lcd).show_page(id(settings_page));
              break;
            case ${APP_STATE_SCREEN_SAVER}:
              id(s3_box_lcd).show_page(id(screen_saver_page));
              break;
            case ${APP_STATE_TOUCHSCREEN_ERROR}:
              id(nav_lock) = true;
              id(touchscreen_error_counter) = 10;
              id(s3_box_lcd).show_page(id(touchscreen_error_page));
              break;
            default:
              ESP_LOGE("change_app_state", "Unknown state: %d", nextState);
          }
      - component.update: s3_box_lcd
  - id: change_va_state
    parameters:
      nextState: int
    then:
      - lambda: ESP_LOGD("change_va_state", "%d", nextState);
      - lambda: id(va_state) = nextState;
      - component.update: s3_box_lcd
  - id: save_ir_button
    parameters:
      buttonIndex: int
      hexString: std::string
    then:
      - lambda: |-
          int arrayIndex = 1; // Start from 1 because the first element will store the count
          int intValue = 0;
          int hexDigitsInInt = 0;
          int* outputArray;
          
          switch (buttonIndex) {
            case 0:
              outputArray = id(mem_ir_code_1);
              break;
            case 1:
              outputArray = id(mem_ir_code_2);
              break;
            case 2:
              outputArray = id(mem_ir_code_3);
              break;
            case 3:
              outputArray = id(mem_ir_code_4);
              break;
            default:
              ESP_LOGE("save_ir_button", "Invalid button index: %d", buttonIndex);
              return;
          }

          for (char c : hexString) {
              if (c == ' ') {
                  if (hexDigitsInInt > 0) {
                      // Store the current intValue and reset for the next hex value
                      if (arrayIndex < 512) {
                          outputArray[arrayIndex++] = intValue;
                      }
                      intValue = 0;
                      hexDigitsInInt = 0;
                  }
              } else {
                  intValue <<= 4; // Shift left by 4 bits to make space for the next hex digit
                  if (c >= '0' && c <= '9') {
                      intValue |= (c - '0');
                  } else if (c >= 'A' && c <= 'F') {
                      intValue |= (10 + c - 'A');
                  } else if (c >= 'a' && c <= 'f') {
                      intValue |= (10 + c - 'a');
                  }
                  hexDigitsInInt++;
                  
                  if (hexDigitsInInt == 8) {
                      if (arrayIndex < 512) {
                          outputArray[arrayIndex++] = intValue;
                      }
                      intValue = 0;
                      hexDigitsInInt = 0;
                  }
              }
          }

          // Handle the last hex value if there is no trailing space
          if (hexDigitsInInt > 0 && arrayIndex < 512) {
              outputArray[arrayIndex++] = intValue;
          }

          // Store the number of values saved into the first element of the array
          outputArray[0] = arrayIndex - 1; // Minus 1 because arrayIndex starts from 1
          ESP_LOGD("save_ir_button", "Saved %d values for %d", arrayIndex - 1, buttonIndex);
          global_preferences->sync();
  - id: send_ir_code
    parameters:
      buttonIndex: int
    then:
      - if:
          condition:
            lambda: |-
              const std::vector<std::string>& codes = id(ir_memory_button_codes);
              if (codes.size() < buttonIndex) {
                ESP_LOGE("send_ir_code", "Invalid button: %d", buttonIndex + 1);
                return false;
              }

              const std::string& code = codes[buttonIndex];
              if (code.length() == 0) {
                ESP_LOGD("send_ir_code", "Button %d is empty", buttonIndex + 1);
                return false;
              }
              return true;
          then:
            - remote_transmitter.transmit_pronto:
                data: !lambda 'return id(ir_memory_button_codes)[buttonIndex].c_str();'
  - id: set_volume
    parameters:
      volume: float
    then:
      - media_player.volume_set: !lambda 'return volume;' #for some reason, 0.5 is no volume
  - id: check_touchscreen_failure
    then:
      - lambda:
          if (!id(ignore_touchscreen_error) && id(gt911_touchscreen).is_failed() && id(touchscreen_error_counter) < 0) {
            id(touchscreen_error_counter) = 10;
            id(change_app_state).execute(${APP_STATE_TOUCHSCREEN_ERROR});
          }

button:
  - id: reboot
    platform: restart
    name: "重新啟動"
  - id: ir_btn_1
    platform: template
    icon: 'mdi:led-off'
    name: "IR 按鈕 1"
    on_press:
      then:
        - script.execute:
            id: send_ir_code
                  buttonIndex: 0
  # Touchscreen ir blast button 1
  - id: ts_ir_blast_1_button
    platform: touchscreen
    internal: true
    x_min: 40
    x_max: 88
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_IR_BLAST} && id(enable_ir).state;
            then:
              - script.execute: 
                  id: send_ir_code
                  buttonIndex: 0
  # Touchscreen ir blast button 2
  - id: ts_ir_blast_2_button
    platform: touchscreen
    internal: true
    x_min: 105
    x_max: 153
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_IR_BLAST} && id(enable_ir).state;
            then:
              - script.execute: 
                  id: send_ir_code
                  buttonIndex: 1
  # Touchscreen ir blast button 3
  - id: ts_ir_blast_3_button
    platform: touchscreen
    internal: true
    x_min: 170
    x_max: 218
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_IR_BLAST} && id(enable_ir).state;
            then:
              - script.execute: 
                  id: send_ir_code
                  buttonIndex: 2
  # Touchscreen ir blast button 4
  - id: ts_ir_blast_4_button
    platform: touchscreen
    internal: true
    x_min: 235
    x_max: 283
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_IR_BLAST} && id(enable_ir).state;
            then:
              - script.execute: 
                  id: send_ir_code
                  buttonIndex: 3
  - id: ir_btn_2
    platform: template
    icon: 'mdi:led-off'
    name: "IR 按鈕 2"
    on_press:
      then:
        - script.execute:
            id: send_ir_code
            buttonIndex: 1
  - id: ir_btn_3
    platform: template
    icon: 'mdi:led-off'
    name: "IR 按鈕 3"
    on_press:
      then:
        - script.execute:
            id: send_ir_code
            buttonIndex: 2
  - id: ir_btn_4
    platform: template
    icon: 'mdi:led-off'
    name: "IR 按鈕 4"
    on_press:
      then:
        - script.execute:
            id: send_ir_code
            buttonIndex: 3

binary_sensor:
  # top left hand physical button
  - platform: gpio
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
    name: "左上按鈕"
    entity_category: diagnostic
    on_press:
      - if:
          condition:
            - lambda: return id(touchscreen_error_counter) >= 0;
          then:
            - lambda: |-
                id(ignore_touchscreen_error) = true;
                id(touchscreen_error_counter) = -1;
                id(nav_lock) = false;
                id(change_app_state).execute(${APP_STATE_STATUS});
          else:
            - light.toggle: led
  # red circle home button
  - id: home
    platform: gt911
    name: "Home 鍵"
    index: 0
    on_press:
      - select.next: mem_va_speaker_mode
      - component.update: s3_box_lcd
  # mute switch
  - id: mute
    platform: gpio
    name: "靜音"
    pin:
      number: GPIO1
      inverted: true
    disabled_by_default: true
    entity_category: diagnostic
    on_state: 
      then:
        - lambda: ESP_LOGD("binary_sensor", "Mute button pressed. Device needs to be rebooted before VA will work."); id(mute_error) = true;
        - component.update: s3_box_lcd
  # radar  
  - id: radar_sensor
    platform: gpio
    pin: GPIO21
    disabled_by_default: false
    name: "存在感測器"
    device_class: "occupancy"
    on_press:
      then:
        - lambda: id(radar_last_seen) = -1;
        - if:
            condition:
              - lambda: return id(app_state) == ${APP_STATE_SCREEN_SAVER};
            then:
              - script.execute: 
                  id: change_app_state
                  nextState: !lambda 'return id(wake_app_state);'
    on_release:
      then:
        - wait_until: 
          - lambda: return id(ha_time).now().is_valid();
        - lambda: id(radar_last_seen) = id(ha_time).now().timestamp;
  # Touchscreen previous page
  - id: ts_prev_button
    platform: touchscreen
    internal: true
    x_min: 0
    x_max: 70
    y_min: 170
    y_max: 240
    on_press:
      then:
        - if:
            condition: 
              lambda: return !id(nav_lock) && id(app_state) != ${APP_STATE_LOADING};
            then:
              - script.execute:
                  id: change_app_state
                  nextState: !lambda 'int next = (id(app_state) - 1) % ${NUM_PAGES}; return next ? next : (${NUM_PAGES} - 1);'
  # Touchscreen next page
  - id: ts_next_button
    platform: touchscreen
    internal: true
    x_min: 250
    x_max: 320
    y_min: 170
    y_max: 240
    on_press:
      then:
        - if:
            condition: 
              lambda: return !id(nav_lock) && id(app_state) != ${APP_STATE_LOADING};
            then:
              - script.execute:
                  id: change_app_state
                  nextState: !lambda 'int next = (id(app_state) + 1) % ${NUM_PAGES}; return next ? next : 1;'
  # Touchscreen ir memory button 1
  - id: ts_ir_memory_1_button
    platform: touchscreen
    internal: true
    x_min: 40
    x_max: 88
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 0 && id(enable_ir).state;
            then:
              - lambda: |-
                  id(ir_memory_button_selected) = 0;
                  id(ir_learning_state) = 1;
                  id(nav_lock) = true;
              - component.update: s3_box_lcd
  # Touchscreen ir memory button 2
  - id: ts_ir_memory_2_button
    platform: touchscreen
    internal: true
    x_min: 105
    x_max: 153
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 0 && id(enable_ir).state;
            then:
              - lambda: |-
                  id(ir_memory_button_selected) = 1;
                  id(ir_learning_state) = 1;
                  id(nav_lock) = true;
              - component.update: s3_box_lcd
  # Touchscreen ir memory button 3
  - id: ts_ir_memory_3_button
    platform: touchscreen
    internal: true
    x_min: 170
    x_max: 223
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 0 && id(enable_ir).state;
            then:
              - lambda: |-
                  id(ir_memory_button_selected) = 2;
                  id(ir_learning_state) = 1;
                  id(nav_lock) = true;
              - component.update: s3_box_lcd
  # Touchscreen ir memory button 4
  - id: ts_ir_memory_4_button
    platform: touchscreen
    internal: true
    x_min: 235
    x_max: 283
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 0 && id(enable_ir).state;
            then:
              - lambda: |-
                  id(ir_memory_button_selected) = 3;
                  id(ir_learning_state) = 1;
                  id(nav_lock) = true;
              - component.update: s3_box_lcd
  # Touchscreen ir memory cancel
  - id: ts_ir_memory_cancel_button
    platform: touchscreen
    internal: true
    x_min: 130
    x_max: 190
    y_min: 200
    y_max: 225
    on_press:
      then:
        - if:
            condition: 
              - lambda: return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) != 0;
            then:
              - lambda: |-
                  id(ir_learning_state) = 0;
                  id(ir_learning_step) = 0;
                  id(nav_lock) = false;
                  id(ir_memory_button_selected) = -1;
                  id(ir_memory_recorded_codes).clear();
                  id(ir_memory_recording_codes).clear();
              - component.update: s3_box_lcd
  # Touchscreen ir blast button 1
  - id: ts_ir_blast_1_button
    platform: touchscreen
    internal: true
    x_min: 40
    x_max: 88
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_IR_BLAST} && id(enable_ir).state;
            then:
              - script.execute: 
                  id: send_ir_code
                  buttonIndex: 0                  
  # Touchscreen volume down
  - id: settings_volume_down
    platform: touchscreen
    internal: true
    x_min: 180
    x_max: 210
    y_min: 90
    y_max: 120
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_SETTINGS};
            then:
              - lambda: |-
                  float volume = id(speaker_media_player).volume;
                  if (volume > 0.5) {
                    volume -= 0.05;
                    if (volume < 0.5)
                      volume = 0.5;
                    id(set_volume).execute(volume);
                  }
              - component.update: s3_box_lcd
  # Touchscreen volume up
  - id: settings_volume_up
    platform: touchscreen
    internal: true
    x_min: 280
    x_max: 310
    y_min: 90
    y_max: 120
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_SETTINGS};
            then:
              - lambda: |-
                  float volume = id(speaker_media_player).volume;
                  if (volume < 1) {
                    volume += 0.05;
                    if (volume > 1)
                      volume = 1;
                    id(set_volume).execute(volume);
                  }
              - component.update: s3_box_lcd
  # Touchscreen sleep down
  - id: settings_sleep_down
    platform: touchscreen
    internal: true
    x_min: 180
    x_max: 210
    y_min: 130
    y_max: 160
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_SETTINGS};
            then:
              - lambda: |-
                  ESP_LOGD("touchscreen", "sleep down");
                  int sleep = id(mem_settings_sleep_delay).state - 5;
                  if (sleep < 1) {
                    sleep = 1;
                  }
                  auto call = id(mem_settings_sleep_delay).make_call();
                  call.set_value(sleep);
                  call.perform();
              - component.update: s3_box_lcd
  # Touchscreen sleep up
  - id: settings_sleep_up
    platform: touchscreen
    internal: true
    x_min: 280
    x_max: 310
    y_min: 130
    y_max: 160
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_SETTINGS};
            then:
              - lambda: |-
                  ESP_LOGD("touchscreen", "sleep up");
                  int sleep = id(mem_settings_sleep_delay).state + 5;
                  auto call = id(mem_settings_sleep_delay).make_call();
                  call.set_value(sleep);
                  call.perform();
              - component.update: s3_box_lcd
  # Touchscreen mute toggle
  - id: settings_mute
    platform: touchscreen
    internal: true
    x_min: 220
    x_max: 270
    y_min: 50
    y_max: 80
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_SETTINGS};
            then:
              - select.next: mem_va_speaker_mode
              - component.update: s3_box_lcd              

interval:
  - interval: 1s
    then:
      # IR learning loop
      - if:
          condition:
            - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) != 0;'
          then:
            - lambda: |-
                if (!id(ha_time).now().is_valid()) {
                  ESP_LOGE("interval", "time is invalid");
                }

                switch (id(ir_learning_state)) {
                  // button picked, waiting to turn on
                  case 1:
                    switch (id(ir_learning_step)) { 
                      // wait a second
                      case 0:
                        id(ir_learning_step)++;
                        break;
                      case 1:
                        id(ir_learning_state)++;
                        id(ir_learning_step) = 0;
                        break;
                    }
                    break;

                  // waiting for control signal
                  case 2:
                    switch (id(ir_learning_step)) {
                      case 0:
                        id(ir_memory_last_received) = 0;
                        id(ir_memory_recording_codes).clear();
                        id(ir_learning_step)++;
                        break;
                      case 1:
                        int lastReceived = id(ir_memory_last_received);
                        if (lastReceived > 0 && (id(ha_time).now().timestamp - lastReceived) > 1) {
                          id(ir_learning_step) = 0;

                          std::vector<std::string> codes(id(ir_memory_recording_codes));
                          id(ir_memory_recorded_codes).push_back(codes);
                          if (id(ir_memory_recorded_codes).size() < 2) {
                            // record again
                            id(ir_learning_state) = 1;
                            break;
                          }

                          // # analyze patterns, record code
                          // # ----- begin algorithm --------------------
                          const std::vector<std::string> &vec1 = id(ir_memory_recorded_codes)[0];
                          const std::vector<std::string> &vec2 = id(ir_memory_recorded_codes)[1];
                          std::set<int> set2;
                          for (const auto &str : vec2) {
                              set2.insert(str.length());
                          }

                          int longestCommonStringLength = 0;
                          std::string longestString;

                          // Iterate over the first vector and check for common strings in the set
                          for (const auto &str : vec1) {
                              int str1Length = str.length();
                              if (set2.find(str1Length) != set2.end()) {
                                  if (str1Length > longestCommonStringLength) {
                                      longestCommonStringLength = str1Length;
                                      longestString = str;
                                  }
                              }
                          }
                          // # ----- end algorithm --------------------

                          // only an even number of codes
                          int numSpaces = std::count(longestString.begin(), longestString.end(), ' ');
                          if (longestString.size() > 5 && numSpaces % 2 == 0) {
                            longestString.resize(longestString.size() - 5);
                          }

                          id(ir_memory_button_codes)[id(ir_memory_button_selected)] = longestString;
                          
                          ESP_LOGD("algorithm", longestString.c_str());
                          
                          id(save_ir_button).execute(id(ir_memory_button_selected), longestString);

                          id(nav_lock) = false;
                          id(ir_learning_state) = 0;
                          id(ir_memory_button_selected) = -1;
                          id(ir_memory_recorded_codes).clear();
                          id(ir_memory_recording_codes).clear();
                        }
                        break;
                    }
                }
            - delay: 100ms
            - component.update: s3_box_lcd
      # Screen saver activation
      - if:
          condition: 
            - lambda: |-
                return id(app_state) != ${APP_STATE_LOADING} && 
                  id(radar_last_seen) > 0 && 
                  (id(ha_time).now().timestamp - id(radar_last_seen) >= id(mem_settings_sleep_delay).state);
          then:
            - if:
                condition:
                  - lambda: 'return id(app_state) == ${APP_STATE_SCREEN_SAVER};'
                then:
                  - component.update: s3_box_lcd
                else:
                  - lambda: id(wake_app_state) = id(app_state);
                  - script.execute: 
                      id: change_app_state
                      nextState: ${APP_STATE_SCREEN_SAVER}
      - if:
          condition:
            - lambda: return !id(ignore_touchscreen_error) && id(touchscreen_error_counter) >= 0;
          then:
            - lambda: |-
                id(touchscreen_error_counter)--;
                if (id(touchscreen_error_counter) == 0) {
                  id(reboot).press();
                }
            - component.update: s3_box_lcd

remote_receiver:
  id: ir_rx
  pin: 
    number: 38
    inverted: true
  dump: all
  on_pronto:
    then:
      - if:
          condition:
            - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
          then:
            - lambda: |-
                ESP_LOGD("remote_receiver", x.data.c_str());
                id(ir_memory_recording_codes).push_back(x.data);
            - component.update: s3_box_lcd
  on_abbwelcome:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_aeha:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_byronsx:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_canalsat:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_coolix:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_dish:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_dooya:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_drayton:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_jvc:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_keeloq:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_haier:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_lg:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_magiquest:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_midea:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_nec:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_nexa:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_panasonic:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_pioneer:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_rc5:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_rc6:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_rc_switch:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_roomba:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_samsung:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_samsung36:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_sony:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_toshiba_ac:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_mirage:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  
remote_transmitter:
  id: ir_tx
  pin: 
    number: 39
    inverted: false
  carrier_duty_percent: 50%

display:
  - platform: ili9xxx
    id: s3_box_lcd
    model: S3BOX
    cs_pin: 5
    dc_pin: 4
    invert_colors: false  # 設置為 true 或 false，依需求調整
    reset_pin:
      number: 48
      inverted: true
    update_interval: never
    pages:
      - id: loading_page
        lambda: |-
          it.fill(Color::BLACK);
          it.image((320 / 2), (240 / 2), id(loading_img), ImageAlign::CENTER);

      - id: status_page
        lambda: |-
          int y = 0;
          int x = 15;
          int xinc = 65;

          it.fill(Color::BLACK);
          
          // # print nav buttons
          if (!id(nav_lock)) {
            it.print(5, (240 - 5), id(font_icon_large), TextAlign::BOTTOM_LEFT, "\U000F004F");
            it.print((320 - 5), (240 - 5), id(font_icon_large), TextAlign::BOTTOM_RIGHT, "\U000F0056");
          }

          it.print((320 / 2), 0, id(font_large), yellow, TextAlign::TOP_CENTER, "- 狀態 -");
          // 在右上角顯示時間，x 值接近螢幕右側，y 設為 0 表示在頂部顯示
          it.strftime(320 - 10, 15, id(font_small), white, TextAlign::TOP_RIGHT, "%I:%M", id(ha_time).now());

          // 根據當前時間小時部分判斷時間段並顯示中文描述
          auto current_hour = id(ha_time).now().hour;
          if (current_hour >= 0 && current_hour <= 5) {
            it.print(320 - 80, 15, id(font_small), white, "凌晨");
          } else if (current_hour >= 6 && current_hour <= 8) {
            it.print(320 - 80, 15, id(font_small), white, "早上");
          } else if (current_hour >= 9 && current_hour <= 11) {
            it.print(320 - 80, 15, id(font_small), white, "上午");
          } else if (current_hour >= 12 && current_hour <= 13) {
            it.print(320 - 80, 15, id(font_small), white, "中午");
          } else if (current_hour >= 14 && current_hour <= 18) {
            it.print(320 - 80, 15, id(font_small), white, "下午");
          } else if (current_hour >= 19 && current_hour <= 21) {
            it.print(320 - 80, 15, id(font_small), white, "晚上");
          } else if (current_hour >= 22 && current_hour <= 23) {
            it.print(320 - 80, 15, id(font_small), white, "深夜");
          }
          
          y += 42;

          if (network::is_connected()) {
            it.print(x, y, id(font_icon_small), lime, "\U000F16BD");
          } else {
            it.print(x, y, id(font_icon_small), red, "\U000F16BC");
          }
          x += xinc;

          if (api::global_api_server->is_connected()) {
            it.print(x, y, id(font_icon_small), blue, "\U000F07D0");
          } else {
            it.print(x, y, id(font_icon_small), red, "\U000F087B");
          }
          x += xinc;

          x += 3; // oddly spaced icon
          if (id(battery_voltage).has_state ()) {
              if (id(battery_voltage).state <= 2.7) {
                  // Replace battery, less than 10%
                  it.print(x, y, id(font_icon_small), "\U000F10CD");
              } else if (id(battery_percent).state >= 98) {
                  // # mdi-battery
                  it.print(x, y, id(font_icon_small), green, "\U000F0079");
              } else if (id(battery_percent).state >= 90) {
                  // # mdi-battery-90
                  it.print(x, y, id(font_icon_small), green, "\U000F0082");
              } else if (id(battery_percent).state >= 80) {
                  // # mdi-battery-80
                  it.print(x, y, id(font_icon_small), green, "\U000F0081");
              } else if (id(battery_percent).state >= 70) {
                  // # mdi-battery-70
                  it.print(x, y, id(font_icon_small), green, "\U000F0080");
              } else if (id(battery_percent).state >= 60) {
                  // # mdi-battery-60
                  it.print(x, y, id(font_icon_small), green, "\U000F007F");
              } else if (id(battery_percent).state >= 50) {
                  // # mdi-battery-50
                  it.print(x, y, id(font_icon_small), amber, "\U000F007E");
              } else if (id(battery_percent).state >= 40) {
                  // # mdi-battery-40
                  it.print(x, y, id(font_icon_small), amber, "\U000F007D");
              } else if (id(battery_percent).state >= 30) {
                  // # mdi-battery-30
                  it.print(x, y, id(font_icon_small), red, "\U000F007C");
              } else if (id(battery_percent).state >= 20) {
                  // # mdi-battery-20
                  it.print(x, y, id(font_icon_small), red, "\U000F007B");
              } else if (id(battery_percent).state >= 10) {
                  // # mdi-battery-10
                  it.print(x, y, id(font_icon_small), red, "\U000F007A");
              }
          }
          x += xinc;

          if (id(enable_ir).state) {
            it.print(x, y, id(font_icon_small), yellow, "\U000F0330");
          } else {
            it.print(x, y, id(font_icon_small), blue_dark, "\U000F032E");
          }
          x += xinc;
          
          x -= 10; // oddly spaced icon
          it.print(x, y, id(font_icon_small), blue, "\U000F050F");
          it.printf(x + 22, y + 41, id(font_small), black, TextAlign::BOTTOM_CENTER, "%.f", id(s3temp).state);
          it.printf(x + 23, y + 41, id(font_small), black, TextAlign::BOTTOM_CENTER, "%.f", id(s3temp).state);

          // VA status image
          y = (it.get_height() / 2) - 30;
          if (id(mute_error)) {
            it.image((it.get_width() / 2), y, id(error_img), ImageAlign::TOP_CENTER);
            y += 105;
            it.print((it.get_width() / 2), y, id(font_small), red, TextAlign::TOP_CENTER, "硬體靜音鈕按下。");
            y += 15;
            it.print((it.get_width() / 2), y, id(font_small), red, TextAlign::TOP_CENTER, "重啟裝置以回復語音助理。");
          } else {
            switch (id(va_state)) {
              case ${VA_STATE_NOT_READY}:
                it.image((it.get_width() / 2), y, id(notready_img), ImageAlign::TOP_CENTER);
                break;
              case ${VA_STATE_IDLE}:
                it.image((it.get_width() / 2), y, id(idle_img), ImageAlign::TOP_CENTER);
                break;
              case ${VA_STATE_LISTENING}:
                it.image((it.get_width() / 2), y, id(listening_img), ImageAlign::TOP_CENTER);
                break;
              case ${VA_STATE_THINKING}:
                it.image((it.get_width() / 2), y, id(thinking_img), ImageAlign::TOP_CENTER);
                break;
              case ${VA_STATE_REPLYING}:
                it.image((it.get_width() / 2), y, id(replying_img), ImageAlign::TOP_CENTER);
                break;
              case ${VA_STATE_ERROR}:
                it.image((it.get_width() / 2), y, id(error_img), ImageAlign::TOP_CENTER);
                break;
            }
            
            y += 68;
            if (id(mem_va_speaker_mode).state == "${VA_SPEAKER_MUTE}") {
              it.print((it.get_width() / 2) + 1, y, id(font_icon_tiny), red, TextAlign::TOP_CENTER, "\U000F00AD");
            } else if (id(mem_va_speaker_mode).state == "${VA_SPEAKER_BEEP}") {
              it.print((it.get_width() / 2) + 1, y, id(font_icon_tiny), yellow, TextAlign::TOP_CENTER, "\U000F009C");
            }
          }

      - id: ir_learn_page
        lambda: |-
          int y = 0;
          int x = 15;
          int xinc = 65; // # must be kept in sync with touchscreen buttons
          int btnRadius = 24;

          it.fill(Color::BLACK);
          it.print((it.get_width() / 2), 0, id(font_large), yellow, TextAlign::TOP_CENTER, "- 紅外線學習 -");
          y += 46;

          // # print nav buttons
          if (!id(nav_lock)) {
            it.print(5, (240 - 5), id(font_icon_large), TextAlign::BOTTOM_LEFT, "\U000F004F");
            it.print((320 - 5), (240 - 5), id(font_icon_large), TextAlign::BOTTOM_RIGHT, "\U000F0056");
          }

          if (!id(enable_ir).state) {
            it.print(320 / 2, 240 / 2, id(font_small), white, TextAlign::TOP_CENTER, "紅外線必須供電方能進行");
            return;
          }

          if (id(ir_memory_button_selected) == -1) {
            // # recording buttons
            it.print(x, y, id(font_small), white, "紅外線記憶按鈕：");
            x = 40;
            y = 66; // # must be kept in sync with touchscreen buttons
            it.filled_circle(x + btnRadius, y + btnRadius, btnRadius, (id(ir_memory_button_codes)[0].length() > 0) ? blue_light : blue_dark);
            it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "1");
            x += xinc;
            it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[1].length() > 0) ? blue_light : blue_dark);
            it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "2");
            x += xinc;
            it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[2].length() > 0) ? blue_light : blue_dark);
            it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "3");
            x += xinc;
            it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[3].length() > 0) ? blue_light : blue_dark);
            it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "4");
          } else {
            it.printf(x, y, id(font_small), white, "錄製紅外線記憶按鈕 %d", id(ir_memory_button_selected) + 1);
            y += 30;
            it.print(x, y, id(font_small), white, "當圖示變成黃色，");
            y += 15;
            it.print(x, y, id(font_small), white, "按下所要錄製的按鈕。");
            y += 15;
            if (id(ir_learning_state) == 2) {
              it.print(320 / 2, y, id(font_icon_small), yellow, TextAlign::TOP_CENTER, "\U000F0330");
            } else {
              it.print(320 / 2, y, id(font_icon_small), blue_dark, TextAlign::TOP_CENTER, "\U000F032E");
            }
            y += 45;
            
            // # cancel button
            y = 200;
            it.filled_rectangle( (320 / 2) - 30, y, 60, 25, red);
            y += 5;
            it.print(320 / 2, y, id(font_small), white, TextAlign::TOP_CENTER, "取消");
          }

      - id: ir_blast_page
        lambda: |-
          it.fill(Color::BLACK);
          it.print((it.get_width() / 2), 0, id(font_large), yellow, TextAlign::TOP_CENTER, "- 紅外線控制 -");

          // # print nav buttons
          if (!id(nav_lock)) {
            it.print(5, (240 - 5), id(font_icon_large), TextAlign::BOTTOM_LEFT, "\U000F004F");
            it.print((320 - 5), (240 - 5), id(font_icon_large), TextAlign::BOTTOM_RIGHT, "\U000F0056");
          }

          if (!id(enable_ir).state) {
            it.print(320 / 2, 240 / 2, id(font_small), white, TextAlign::TOP_CENTER, "紅外線必須供電方能進行");
            return;
          }

          int xinc = 65; // # must be kept in sync with touchscreen buttons
          int btnRadius = 24;

          int x = 40;
          int y = 66; // # must be kept in sync with touchscreen buttons
          it.filled_circle(x + btnRadius, y + btnRadius, btnRadius, (id(ir_memory_button_codes)[0].length() > 0) ? blue_light : blue_dark);
          it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "1");
          x += xinc;
          it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[1].length() > 0) ? blue_light : blue_dark);
          it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "2");
          x += xinc;
          it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[2].length() > 0) ? blue_light : blue_dark);
          it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "3");
          x += xinc;
          it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[3].length() > 0) ? blue_light : blue_dark);
          it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "4");

      - id: voice_assistant_page
        lambda: |-
          it.fill(Color::BLACK);
          it.print((it.get_width() / 2), 0, id(font_large), yellow, TextAlign::TOP_CENTER, "- 語音助理 -");

          // # print nav buttons
          if (!id(nav_lock)) {
            it.print(5, (240 - 5), id(font_icon_large), TextAlign::BOTTOM_LEFT, "\U000F004F");
            it.print((320 - 5), (240 - 5), id(font_icon_large), TextAlign::BOTTOM_RIGHT, "\U000F0056");
          }
          
          // 在右上角顯示時間，x 值接近螢幕右側，y 設為 0 表示在頂部顯示
          it.strftime(320 - 10, 15, id(font_small), white, TextAlign::TOP_RIGHT, "%I:%M", id(ha_time).now());

          // 根據當前時間小時部分判斷時間段並顯示中文描述
          auto current_hour = id(ha_time).now().hour;
          if (current_hour >= 0 && current_hour <= 5) {
            it.print(320 - 80, 15, id(font_small), white, "凌晨");
          } else if (current_hour >= 6 && current_hour <= 8) {
            it.print(320 - 80, 15, id(font_small), white, "早上");
          } else if (current_hour >= 9 && current_hour <= 11) {
            it.print(320 - 80, 15, id(font_small), white, "上午");
          } else if (current_hour >= 12 && current_hour <= 13) {
            it.print(320 - 80, 15, id(font_small), white, "中午");
          } else if (current_hour >= 14 && current_hour <= 18) {
            it.print(320 - 80, 15, id(font_small), white, "下午");
          } else if (current_hour >= 19 && current_hour <= 21) {
            it.print(320 - 80, 15, id(font_small), white, "晚上");
          } else if (current_hour >= 22 && current_hour <= 23) {
            it.print(320 - 80, 15, id(font_small), white, "深夜");
          }

          int x = 15;
          int y = 46;

          // 定義標題的顏色為藍色
          esphome::Color blue_color(0, 200, 0);  // 這裡用 RGB(0, 0, 255) 來表示藍色
          
          // 喚醒詞引擎與揚聲器模式合併顯示在同一行
          it.printf(x, y, id(font_small), blue_color, "喚醒詞引擎：");
          it.printf(x + 90, y, id(font_small), white, "%s    ", id(mem_wake_word_engine_location).state.c_str());
          it.printf(x + 150, y, id(font_small), blue_color, "揚聲器模式：");
          it.printf(x + 240, y, id(font_small), white, "%s", id(mem_va_speaker_mode).state.c_str());
          y += 15;

          // 目前狀態與最後詢問標題放在同一行
          std::string stateStr = "未知";
          switch (id(va_state)) {
            case ${VA_STATE_IDLE}:
              stateStr = "發呆中";
              break;
            case ${VA_STATE_LISTENING}:
              stateStr = "聆聽中";
              break;
            case ${VA_STATE_THINKING}:
              stateStr = "思考中";
              break;
            case ${VA_STATE_NOT_READY}:
              stateStr = "尚未就緒";
              break;
            case ${VA_STATE_REPLYING}:
              stateStr = "回覆中";
              break;
            case ${VA_STATE_ERROR}:
              stateStr = "錯誤";
              break;
            case ${VA_STATE_MUTED}:
              stateStr = "靜音";
              break;
          }
          
          // 目前狀態與最後詢問標題放在同一行，標題部分使用藍色
          it.printf(x, y, id(font_small), blue_color, "目前狀態：");
          it.printf(x + 90, y, id(font_small), white, "%s    ", stateStr.c_str());
          it.printf(x + 150, y, id(font_small), blue_color, "最後對話：");
          y += 15;

          // 如果有最後詢問的內容，顯示在下一行
          if (id(va_request).state.length() > 0) {
            print_wrapped_text(it, x, y, id(font_small), white, id(va_request).state.c_str(), 290);
            y += 30; // 適當地增加y以分隔下一段
          }
          
          // 如果有最後回應的內容，顯示在下一行，標題部分使用藍色
          if (id(va_response).state.length() > 0) {
            it.printf(x, y, id(font_small), blue_color, "最後回應：");
            y += 15;
            print_wrapped_text(it, x, y, id(font_small), white, id(va_response).state.c_str(), 290); // 假设 290 是最大宽度
          }

          if (id(mute_error)) {
            y += 15;
            it.print(x, y, id(font_small), red, "硬體靜音錯誤、重啟裝置以回復語音助理。");
          }

      - id: settings_page
        lambda: |-
          it.fill(Color::BLACK);
          it.print((it.get_width() / 2), 0, id(font_large), yellow, TextAlign::TOP_CENTER, "- 設定 -");

          // # print nav buttons
          if (!id(nav_lock)) {
            it.print(5, (240 - 5), id(font_icon_large), TextAlign::BOTTOM_LEFT, "\U000F004F");
            it.print((320 - 5), (240 - 5), id(font_icon_large), TextAlign::BOTTOM_RIGHT, "\U000F0056");
          }

          int x = 15;
          int y = 50;

          it.print(x, y, id(font_medium), white, "語音助理狀態：");
          if (id(mem_va_speaker_mode).state == "${VA_SPEAKER_SPEECH}") {
            it.print(x + 230, y - 8, id(font_icon_small), lime, TextAlign::TOP_CENTER, "\U000F01F2");
          } else if (id(mem_va_speaker_mode).state == "${VA_SPEAKER_BEEP}") {
            it.print(x + 230, y - 8, id(font_icon_small), yellow, TextAlign::TOP_CENTER, "\U000F009A");
          } else {
            it.print(x + 230, y - 8, id(font_icon_small), red, TextAlign::TOP_CENTER, "\U000F00AD");
          }

          y += 40;
          int volume = (id(speaker_media_player).volume - 0.499) * 200;
          it.print(x, y, id(font_medium), white, TextAlign::TOP_LEFT, "音量：");
          it.printf(x + 230, y, id(font_medium), white, TextAlign::TOP_CENTER, "%i%%", volume);
          it.print(x + 180, y, id(font_icon_tiny), blue_light, TextAlign::TOP_CENTER, "\U000F0375");
          it.print(x + 280, y, id(font_icon_tiny), blue_light, TextAlign::TOP_CENTER, "\U000F0416");

          y += 40;
          it.print(x, y, id(font_medium), white, TextAlign::TOP_LEFT, "睡眠：");
          it.printf(x + 230, y, id(font_medium), white, TextAlign::TOP_CENTER, "%is", (int)id(mem_settings_sleep_delay).state);
          it.print(x + 180, y, id(font_icon_tiny), blue_light, TextAlign::TOP_CENTER, "\U000F0375");
          it.print(x + 280, y, id(font_icon_tiny), blue_light, TextAlign::TOP_CENTER, "\U000F0416");

      - id: screen_saver_page
        lambda: |-
          std::string output;
          switch (id(ha_time).now().timestamp % 10) {
            case 0:
            case 1:
            case 2:
            case 3:
              return;
            case 4:
            case 5:
              output = "😴";
              break;
            case 6:
            case 7:
              output = "😴😴";
              break;
            case 8:
            case 9:
              output = "😴😴😴";
              break;
          }
          it.print(320 / 2 - 52, 240 / 2, id(font_extra_large), grey_dark, TextAlign::CENTER_LEFT, output.c_str());

      - id: touchscreen_error_page
        lambda: |-
          it.fill(Color::BLACK);
          
          int x = 15;
          int y = 15;
          
          it.print(x, y, id(font_medium), white, TextAlign::TOP_LEFT, "！錯誤！");
          y += 25;

          it.print(x, y, id(font_medium), white, TextAlign::TOP_LEFT, "觸控畫面設定失敗，");
          y += 25;

          it.printf(x, y, id(font_medium), white, TextAlign::TOP_LEFT, "裝置即將於 %i 秒後重啟。", id(touchscreen_error_counter));
          y += 50;

          it.print(x, y, id(font_medium), white, TextAlign::TOP_LEFT, "欲取消重啟，");
          y += 25;

          it.print(x, y, id(font_medium), white, TextAlign::TOP_LEFT, "請按下左上按鈕。");
          y += 25;
